-- Exercises week 5!

import Test.QuickCheck
import Prelude hiding (length)

-- | 1.
-- (*) Define the @length@ function using map and sum
length :: [a] -> Int
length xs = sum $ map (const 1) xs

-- (*) What does map (+1) (map (+1) xs) do?
{- ANSWER: 
    Given that xs is a list of elements of the instance Num, what happens is that first 
    @map (+1)@ is applied, resulting in the same list but where the elements has been 
    increased by 1. Then the outer map is applied which does the same thing. 
    It can be rewritten into -> map (+2) xs 

    In general about @map f (map g xs)@ it can be said that it is the same thing as
    map (f . g) xs -}

-- Give the type of, and define the function @iter@ so that
-- iter n f x = f (f (... (f x)))

iter :: Int -> (a -> a) -> (a -> a)
iter 0 f = id
iter n f = f . iter (n-1) f

-- What is the type and effect of the following function?
-- \n -> iter n succ
function :: Enum a => Int -> (a -> a)
function = \n -> iter n succ

-- (*) How would you define the sum of the squares of the
--  natural numbers 1 to n using @map@ and @foldr@?
sumOfSquares :: Int -> Int
sumOfSquares n = foldr (+) 0 (map (^2) [1..n])

-- How does the following function behave?
mystery xs = foldr (++) [] (map sing xs)
    where
        sing x = [x]

{- ANSWER: It first applies sing to every element in xs. E.g (map sing [1,2,3] -> [[1],[2],[3])
   Then foldr is applied with the operator (++), which concatinates all elementlists into
   one list with all the elements, which simply is the list we started with. -}

-- (*) If id is the polymorphic identity function, defined by @id x = x@, explain the
-- behaviour of the expressions (id . f)

{- ANSWER: The expression first applies f to an argument. Then, the identity function is
           applied to the result of f, which just returns that result. -}


-- | 2(*). List Comprehensions and Higher-Order Functions
-- Can you rewrite the following list comprehensions using @map@ and @filter@? Might need @concat@

no1,no1' :: Num a => [a] -> [a]
no1 xs =  [ x+1 | x <- xs ]
no1'   =  map (+1)
prop_1 xs = no1 xs == no1' xs

no2,no2' :: Num a => [a] -> [a] -> [a]
no2 xs ys  = [ x+y | x <- xs, y <- ys ]
no2' xs ys = concat (map (\x -> map (\y -> x+y) ys) xs) -- Tricky
prop_2 xs ys = no2 xs ys == no2' xs ys

no3,no3' :: (Num a, Ord a) => [a] -> [a]
no3 xs  =  [ x+2 | x <- xs, x > 3 ]
no3' xs =  map (+2) $ filter (>3) xs
prop_3 xs = no3 xs == no3' xs

no4,no4' :: Num a => [(a,b)] -> [a]
no4 xys  = [ x+3 | (x,_) <- xys ]
no4'     = map ((+3) . fst)
prop_4 xys = no4 xys == no4' xys

no5,no5' :: (Ord a, Num a) => [(a,a)] -> [a]
no5 xys = [ x+4 | (x,y) <- xys, x+y < 5 ]
no5'    = map ((+4) . fst) . filter (\(x,y) -> x+y < 5)
prop_5  xys = no5 xys == no5' xys

no6,no6' :: (Eq a,Num a) => [Maybe a] -> [a]
no6 mxs =  [ x+5 | Just x <- mxs ]
no6'    = map (\(Just x) -> x+5) . filter (/= Nothing)
prop_6 mxs = no6 mxs == no6' mxs

-- Can you do it the other way around? I.e rewrite the following expressions as list comprehensions
prop1 xs    = [x+3 | x <- xs]               == map (+3) xs
prop2 xs    = [x | x <- xs, x > 7]          == filter (>7) xs
prop3 xs ys = [(x,y) | x <- xs, y <- ys]    == concat (map (\x -> map (\y -> (x,y)) ys) xs)
prop4 xys   = [x+y | (x,y) <- xys, x+y > 3] == filter (>3) (map (\(x,y) -> x+y) xys)

-- | 3(*). Generating Lists

-- A.
-- Write a generator such that @listOf n g@ generates a list of n elements,
-- where each element is generated by g.

listOfLength :: Int -> Gen a -> Gen [a]
listOfLength n gen = sequence [gen | i <- [1..n]] -- OMG this is hard, copied from solutions...

-- What property would you write to test that your generator behaves as it should?
idkHowToWriteThisProperty = undefined

-- B.
pairsOfEqualLengthLists :: Gen a -> Gen ([a],[a])
pairsOfEqualLengthLists gen = do
    n <- choose (1,5)
    xs <- listOfLength (abs n) gen
    ys <- listOfLength (abs n) gen
    return (xs,ys)

-- This generator is for testing
genNum :: Gen Int
genNum = do
    n <- choose (1,10)
    return n

-- C.

-- WTF THIS IS WAY TOO HARD I DON'T KNOW HOW TO SOLVE THIS SH*T!

-- | 4. Generating Ordered Lists

orderedList' :: Gen [Integer] -- This was also hard to think of...
orderedList' = do
    x  <- arbitrary
    ds <- arbitrary
    return (make x ds)
     where
        make x []     = []
        make x (d:ds) = x : make (x+abs d) ds